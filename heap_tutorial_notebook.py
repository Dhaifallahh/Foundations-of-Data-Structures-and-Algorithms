{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Complete Heap Data Structure Tutorial\n",
    "\n",
    "## Table of Contents\n",
    "1. [Introduction to Heaps](#introduction)\n",
    "2. [Basic Heap Implementation](#basic-implementation)\n",
    "3. [Advanced Heap Applications](#advanced-applications)\n",
    "4. [Practice Problems](#practice-problems)\n",
    "5. [Real-World Examples](#real-world-examples)\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Introduction to Heaps {#introduction}\n",
    "\n",
    "A **heap** is a complete binary tree that satisfies the heap property:\n",
    "- **Min-Heap**: Parent ≤ Children\n",
    "- **Max-Heap**: Parent ≥ Children\n",
    "\n",
    "### Key Properties:\n",
    "- Complete binary tree structure\n",
    "- Efficient array representation\n",
    "- O(log n) insert and delete operations\n",
    "- O(1) access to min/max element"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's start with basic heap navigation functions\n",
    "def parent(i):\n",
    "    \"\"\"Get parent index of node at index i\"\"\"\n",
    "    return i // 2\n",
    "\n",
    "def left_child(i):\n",
    "    \"\"\"Get left child index of node at index i\"\"\"\n",
    "    return 2 * i\n",
    "\n",
    "def right_child(i):\n",
    "    \"\"\"Get right child index of node at index i\"\"\"\n",
    "    return 2 * i + 1\n",
    "\n",
    "# Test the navigation functions\n",
    "print(\"Navigation Functions Test:\")\n",
    "print(f\"Parent of node 6: {parent(6)})  # Should be 3\")\n",
    "print(f\"Left child of node 3: {left_child(3)}  # Should be 6\")\n",
    "print(f\"Right child of node 3: {right_child(3)}  # Should be 7\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Basic Heap Implementation {#basic-implementation}\n",
    "\n",
    "Let's implement both Min-Heap and Max-Heap from scratch:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class MinHeap:\n",
    "    \"\"\"Complete Min-Heap implementation\"\"\"\n",
    "    \n",
    "    def __init__(self):\n",
    "        self.H = [None]  # Index 0 unused for easier math\n",
    " \n",
    "    def size(self):\n",
    "        return len(self.H) - 1\n",
    "    \n",
    "    def __repr__(self):\n",
    "        return str(self.H[1:])\n",
    "        \n",
    "    def satisfies_assertions(self):\n",
    "        \"\"\"Check if heap property is maintained\"\"\"\n",
    "        for i in range(2, len(self.H)):\n",
    "            assert self.H[i] >= self.H[i//2], f'Min heap property fails at position {i//2}, parent: {self.H[i//2]}, child: {self.H[i]}'\n",
    "        print(\"✅ Min-heap property satisfied!\")\n",
    "    \n",
    "    def min_element(self):\n",
    "        \"\"\"Get minimum element (root) without removing it\"\"\"\n",
    "        if self.size() == 0:\n",
    "            return None\n",
    "        return self.H[1]\n",
    "\n",
    "    def bubble_up(self, index):\n",
    "        \"\"\"Move element up until heap property is satisfied\"\"\"\n",
    "        assert index >= 1\n",
    "        if index == 1: \n",
    "            return \n",
    "        parent_index = index // 2\n",
    "        if self.H[parent_index] <= self.H[index]:  # Heap property satisfied\n",
    "            return \n",
    "        else:\n",
    "            # Swap with parent and continue\n",
    "            self.H[parent_index], self.H[index] = self.H[index], self.H[parent_index]\n",
    "            self.bubble_up(parent_index)\n",
    "    \n",
    "    def bubble_down(self, index):\n",
    "        \"\"\"Move element down until heap property is satisfied\"\"\"\n",
    "        assert index >= 1 and index < len(self.H)\n",
    "        lchild_index = 2 * index\n",
    "        rchild_index = 2 * index + 1\n",
    "        \n",
    "        # Get child values (or infinity if they don't exist)\n",
    "        lchild_value = self.H[lchild_index] if lchild_index < len(self.H) else float('inf')\n",
    "        rchild_value = self.H[rchild_index] if rchild_index < len(self.H) else float('inf')\n",
    "        \n",
    "        # If current element is already smallest, we're done\n",
    "        if self.H[index] <= min(lchild_value, rchild_value):\n",
    "            return \n",
    "        \n",
    "        # Find the smaller child and swap\n",
    "        min_child_value, min_child_index = min((lchild_value, lchild_index), (rchild_value, rchild_index))\n",
    "        self.H[index], self.H[min_child_index] = self.H[min_child_index], self.H[index]\n",
    "        self.bubble_down(min_child_index)\n",
    "        \n",
    "    def insert(self, elt):\n",
    "        \"\"\"Insert new element into heap\"\"\"\n",
    "        self.H.append(elt)\n",
    "        self.bubble_up(len(self.H) - 1)\n",
    "        \n",
    "    def delete_min(self):\n",
    "        \"\"\"Remove and return the minimum element\"\"\"\n",
    "        if self.size() == 0:\n",
    "            return None\n",
    "        if self.size() == 1:\n",
    "            return self.H.pop()\n",
    "        \n",
    "        min_val = self.H[1]\n",
    "        # Replace root with last element\n",
    "        self.H[1] = self.H.pop()\n",
    "        # Restore heap property\n",
    "        self.bubble_down(1)\n",
    "        return min_val"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test MinHeap implementation\n",
    "print(\"=== Testing MinHeap ===\")\n",
    "h = MinHeap()\n",
    "\n",
    "# Test insertions\n",
    "elements = [5, 2, 4, -1, 7, 3, 6]\n",
    "print(f\"Inserting elements: {elements}\")\n",
    "\n",
    "for elt in elements:\n",
    "    h.insert(elt)\n",
    "    print(f\"After inserting {elt}: {h}, min = {h.min_element()}\")\n",
    "\n",
    "h.satisfies_assertions()\n",
    "\n",
    "# Test deletions\n",
    "print(\"\\nTesting deletions:\")\n",
    "while h.size() > 0:\n",
    "    min_val = h.delete_min()\n",
    "    print(f\"Deleted {min_val}, heap now: {h}\")\n",
    "    if h.size() > 0:\n",
    "        h.satisfies_assertions()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class MaxHeap:\n",
    "    \"\"\"Complete Max-Heap implementation\"\"\"\n",
    "    \n",
    "    def __init__(self):\n",
    "        self.H = [None]\n",
    "        \n",
    "    def size(self):\n",
    "        return len(self.H) - 1\n",
    "    \n",
    "    def __repr__(self):\n",
    "        return str(self.H[1:])\n",
    "        \n",
    "    def satisfies_assertions(self):\n",
    "        \"\"\"Check if max-heap property is maintained\"\"\"\n",
    "        for i in range(2, len(self.H)):\n",
    "            assert self.H[i] <= self.H[i//2], f'Max heap property fails at position {i//2}, parent: {self.H[i//2]}, child: {self.H[i]}'\n",
    "        print(\"✅ Max-heap property satisfied!\")\n",
    "    \n",
    "    def max_element(self):\n",
    "        \"\"\"Get maximum element (root) without removing it\"\"\"\n",
    "        if self.size() == 0:\n",
    "            return None\n",
    "        return self.H[1]\n",
    "    \n",
    "    def bubble_up(self, index):\n",
    "        \"\"\"Move element up until max-heap property is satisfied\"\"\"\n",
    "        assert index >= 1\n",
    "        if index == 1: \n",
    "            return \n",
    "        parent_index = index // 2\n",
    "        if self.H[parent_index] >= self.H[index]:  # Max-heap property satisfied\n",
    "            return \n",
    "        else:\n",
    "            # Swap with parent and continue\n",
    "            self.H[parent_index], self.H[index] = self.H[index], self.H[parent_index]\n",
    "            self.bubble_up(parent_index)\n",
    "            \n",
    "    def bubble_down(self, index):\n",
    "        \"\"\"Move element down until max-heap property is satisfied\"\"\"\n",
    "        assert index >= 1 and index < len(self.H)\n",
    "        lchild_index = 2 * index\n",
    "        rchild_index = 2 * index + 1\n",
    "        \n",
    "        # Get child values (or negative infinity if they don't exist)\n",
    "        lchild_value = self.H[lchild_index] if lchild_index < len(self.H) else float('-inf')\n",
    "        rchild_value = self.H[rchild_index] if rchild_index < len(self.H) else float('-inf')\n",
    "        \n",
    "        # If current element is already largest, we're done\n",
    "        if self.H[index] >= max(lchild_value, rchild_value):\n",
    "            return \n",
    "        \n",
    "        # Find the larger child and swap\n",
    "        max_child_value, max_child_index = max((lchild_value, lchild_index), (rchild_value, rchild_index))\n",
    "        self.H[index], self.H[max_child_index] = self.H[max_child_index], self.H[index]\n",
    "        self.bubble_down(max_child_index)\n",
    "    \n",
    "    def insert(self, elt):\n",
    "        \"\"\"Insert new element into max-heap\"\"\"\n",
    "        self.H.append(elt)\n",
    "        self.bubble_up(len(self.H) - 1)\n",
    "        \n",
    "    def delete_max(self):\n",
    "        \"\"\"Remove and return the maximum element\"\"\"\n",
    "        if self.size() == 0:\n",
    "            return None\n",
    "        if self.size() == 1:\n",
    "            return self.H.pop()\n",
    "        \n",
    "        max_val = self.H[1]\n",
    "        # Replace root with last element\n",
    "        self.H[1] = self.H.pop()\n",
    "        # Restore heap property\n",
    "        self.bubble_down(1)\n",
    "        return max_val"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test MaxHeap implementation\n",
    "print(\"=== Testing MaxHeap ===\")\n",
    "h = MaxHeap()\n",
    "\n",
    "# Test insertions\n",
    "elements = [5, 2, 4, -1, 7, 3, 6]\n",
    "print(f\"Inserting elements: {elements}\")\n",
    "\n",
    "for elt in elements:\n",
    "    h.insert(elt)\n",
    "    print(f\"After inserting {elt}: {h}, max = {h.max_element()}\")\n",
    "\n",
    "h.satisfies_assertions()\n",
    "\n",
    "# Test deletions\n",
    "print(\"\\nTesting deletions:\")\n",
    "while h.size() > 0:\n",
    "    max_val = h.delete_max()\n",
    "    print(f\"Deleted {max_val}, heap now: {h}\")\n",
    "    if h.size() > 0:\n",
    "        h.satisfies_assertions()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Advanced Heap Applications {#advanced-applications}\n",
    "\n",
    "Now let's implement the advanced data structures from your problem set:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class TopKHeap:\n",
    "    \"\"\"Data structure to maintain the k smallest elements efficiently\"\"\"\n",
    "    \n",
    "    def __init__(self, k):\n",
    "        self.k = k\n",
    "        self.A = []        # Sorted array of k smallest elements\n",
    "        self.H = MinHeap() # Min-heap for remaining elements\n",
    "        \n",
    "    def size(self): \n",
    "        return len(self.A) + self.H.size()\n",
    "    \n",
    "    def get_jth_element(self, j):\n",
    "        \"\"\"Get the j-th smallest element (0-indexed)\"\"\"\n",
    "        assert 0 <= j < self.k\n",
    "        assert j < len(self.A)\n",
    "        return self.A[j]\n",
    "    \n",
    "    def satisfies_assertions(self):\n",
    "        \"\"\"Check data structure invariants\"\"\"\n",
    "        # Check if A is sorted\n",
    "        for i in range(len(self.A) - 1):\n",
    "            assert self.A[i] <= self.A[i+1], f'Array A fails to be sorted at position {i}'\n",
    "        \n",
    "        # Check heap property\n",
    "        if self.H.size() > 0:\n",
    "            # Every element in A should be <= min element in H\n",
    "            for i in range(len(self.A)):\n",
    "                assert self.A[i] <= self.H.min_element(), f'Array element A[{i}] = {self.A[i]} > min heap element {self.H.min_element()}'\n",
    "        \n",
    "        print(\"✅ TopKHeap invariants satisfied!\")\n",
    "        \n",
    "    def insert_into_A(self, elt):\n",
    "        \"\"\"Helper: Insert element into sorted array A\"\"\"\n",
    "        assert len(self.A) < self.k\n",
    "        self.A.append(elt)\n",
    "        # Bubble the new element to its correct position\n",
    "        j = len(self.A) - 1\n",
    "        while j >= 1 and self.A[j] < self.A[j-1]:\n",
    "            self.A[j], self.A[j-1] = self.A[j-1], self.A[j]\n",
    "            j -= 1\n",
    "            \n",
    "    def insert(self, elt):\n",
    "        \"\"\"Insert element into the data structure\"\"\"\n",
    "        size = self.size()\n",
    "        # If we have fewer than k elements, just insert into A\n",
    "        if len(self.A) < self.k:\n",
    "            self.insert_into_A(elt)\n",
    "            return \n",
    "        \n",
    "        # We have k elements in A, decide where new element belongs\n",
    "        if elt <= self.A[self.k-1]:  # Element belongs in top-k\n",
    "            # Displace the largest element in A to heap\n",
    "            displaced = self.A[self.k-1]\n",
    "            self.A[self.k-1] = elt\n",
    "            # Bubble the new element to its correct position\n",
    "            j = self.k - 1\n",
    "            while j >= 1 and self.A[j] < self.A[j-1]:\n",
    "                self.A[j], self.A[j-1] = self.A[j-1], self.A[j]\n",
    "                j -= 1\n",
    "            # Insert displaced element into heap\n",
    "            self.H.insert(displaced)\n",
    "        else:\n",
    "            # Element belongs in heap\n",
    "            self.H.insert(elt)\n",
    "    \n",
    "    def delete_top_k(self, j):\n",
    "        \"\"\"Delete the j-th smallest element from A\"\"\"\n",
    "        assert self.size() > self.k  # Need elements in heap to replace\n",
    "        assert 0 <= j < self.k\n",
    "        \n",
    "        # Shift elements left to remove element at position j\n",
    "        for i in range(j, self.k-1):\n",
    "            self.A[i] = self.A[i+1]\n",
    "        \n",
    "        # Replace the last position with minimum from heap\n",
    "        min_from_heap = self.H.min_element()\n",
    "        self.A[self.k-1] = min_from_heap\n",
    "        self.H.delete_min()\n",
    "    \n",
    "    def __repr__(self):\n",
    "        return f\"TopK(k={self.k}): A={self.A}, H={self.H}\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test TopKHeap\n",
    "print(\"=== Testing TopKHeap ===\")\n",
    "h = TopKHeap(5)\n",
    "\n",
    "# Test from the problem set\n",
    "h.A = [-10, -9, -8, -4, 0]\n",
    "elements_for_heap = [1, 4, 5, 6, 15, 22, 31, 7]\n",
    "for elt in elements_for_heap:\n",
    "    h.H.insert(elt)\n",
    "\n",
    "print('Initial data structure:')\n",
    "print(f'\\t A = {h.A}')\n",
    "print(f'\\t H = {h.H}')\n",
    "h.satisfies_assertions()\n",
    "\n",
    "# Test insertions\n",
    "print('\\nTest 1: Inserting element -2')\n",
    "h.insert(-2)\n",
    "print(f'\\t A = {h.A}')\n",
    "print(f'\\t H = {h.H}')\n",
    "h.satisfies_assertions()\n",
    "\n",
    "print('\\nTest 2: Inserting element -11')\n",
    "h.insert(-11)\n",
    "print(f'\\t A = {h.A}')\n",
    "print(f'\\t H = {h.H}')\n",
    "h.satisfies_assertions()\n",
    "\n",
    "# Test deletions\n",
    "print('\\nTest 3: delete_top_k(3)')\n",
    "h.delete_top_k(3)\n",
    "print(f'\\t A = {h.A}')\n",
    "print(f'\\t H = {h.H}')\n",
    "h.satisfies_assertions()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class MedianMaintainingHeap:\n",
    "    \"\"\"Data structure to maintain running median using two heaps\"\"\"\n",
    "    \n",
    "    def __init__(self):\n",
    "        self.hmin = MinHeap()  # Stores larger half of numbers\n",
    "        self.hmax = MaxHeap()  # Stores smaller half of numbers\n",
    "        \n",
    "    def satisfies_assertions(self):\n",
    "        \"\"\"Check data structure invariants\"\"\"\n",
    "        if self.hmin.size() == 0:\n",
    "            assert self.hmax.size() == 0\n",
    "            return \n",
    "        if self.hmax.size() == 0:\n",
    "            assert self.hmin.size() == 1\n",
    "            return \n",
    "        \n",
    "        # 1. max of max-heap <= min of min-heap\n",
    "        assert self.hmax.max_element() <= self.hmin.min_element(), \\\n",
    "            f'Max element of max heap = {self.hmax.max_element()} > min element of min heap {self.hmin.min_element()}'\n",
    "        \n",
    "        # 2. size constraint: |hmax| == |hmin| or |hmax| == |hmin| - 1\n",
    "        s_min = self.hmin.size()\n",
    "        s_max = self.hmax.size()\n",
    "        assert (s_min == s_max or s_max == s_min - 1), \\\n",
    "            f'Heap sizes unbalanced. Min heap: {s_min}, Max heap: {s_max}'\n",
    "        \n",
    "        print(\"✅ MedianMaintainingHeap invariants satisfied!\")\n",
    "    \n",
    "    def __repr__(self):\n",
    "        return f'MaxHeap: {self.hmax} | MinHeap: {self.hmin}'\n",
    "    \n",
    "    def get_median(self):\n",
    "        \"\"\"Get the current median\"\"\"\n",
    "        if self.hmin.size() == 0:\n",
    "            assert self.hmax.size() == 0, 'Sizes are not balanced'\n",
    "            raise ValueError('Cannot get median from empty structure')\n",
    "            \n",
    "        if self.hmax.size() == 0:\n",
    "            assert self.hmin.size() == 1, 'Sizes are not balanced'\n",
    "            return self.hmin.min_element()\n",
    "        \n",
    "        # If sizes are equal, median is average\n",
    "        if self.hmin.size() == self.hmax.size():\n",
    "            return (self.hmax.max_element() + self.hmin.min_element()) / 2.0\n",
    "        else:\n",
    "            # hmin has one more element\n",
    "            return self.hmin.min_element()\n",
    "    \n",
    "    def balance_heap_sizes(self):\n",
    "        \"\"\"Ensure heap size constraints are maintained\"\"\"\n",
    "        s_min = self.hmin.size()\n",
    "        s_max = self.hmax.size()\n",
    "        \n",
    "        if s_max > s_min + 1:\n",
    "            # Max heap too big, move its max to min heap\n",
    "            max_val = self.hmax.delete_max()\n",
    "            self.hmin.insert(max_val)\n",
    "        elif s_min > s_max + 1:\n",
    "            # Min heap too big, move its min to max heap\n",
    "            min_val = self.hmin.delete_min()\n",
    "            self.hmax.insert(min_val)\n",
    "    \n",
    "    def insert(self, elt):\n",
    "        \"\"\"Insert new element and maintain median\"\"\"\n",
    "        # Handle empty case\n",
    "        if self.hmin.size() == 0:\n",
    "            self.hmin.insert(elt)\n",
    "            return \n",
    "            \n",
    "        if self.hmax.size() == 0:\n",
    "            assert self.hmin.size() == 1\n",
    "            if elt > self.hmin.min_element():\n",
    "                # New element goes to min heap\n",
    "                current_min = self.hmin.delete_min()\n",
    "                self.hmin.insert(elt)\n",
    "                self.hmax.insert(current_min)\n",
    "            else:\n",
    "                # New element goes to max heap\n",
    "                self.hmax.insert(elt)\n",
    "            return \n",
    "        \n",
    "        # Both heaps non-empty: insert based on value\n",
    "        if elt <= self.hmax.max_element():\n",
    "            # Insert into max heap (smaller half)\n",
    "            self.hmax.insert(elt)\n",
    "        else:\n",
    "            # Insert into min heap (larger half)\n",
    "            self.hmin.insert(elt)\n",
    "        \n",
    "        # Balance the heaps\n",
    "        self.balance_heap_sizes()\n",
    "        \n",
    "    def delete_median(self):\n",
    "        \"\"\"Delete the current median\"\"\"\n",
    "        if self.hmax.size() >= self.hmin.size():\n",
    "            self.hmax.delete_max()\n",
    "        else:\n",
    "            self.hmin.delete_min()\n",
    "        self.balance_heap_sizes()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test MedianMaintainingHeap\n",
    "print(\"=== Testing MedianMaintainingHeap ===\")\n",
    "m = MedianMaintainingHeap()\n",
    "\n",
    "elements = [1, 5, 2, 4, 18, -4, 7, 9]\n",
    "expected_medians = [1, 3.0, 2, 3.0, 4, 3.0, 4, 4.5]\n",
    "\n",
    "print('Inserting elements and tracking median:')\n",
    "for i, elt in enumerate(elements):\n",
    "    m.insert(elt)\n",
    "    median = m.get_median()\n",
    "    print(f'After inserting {elt:2d}: {m}')\n",
    "    print(f'                    Median = {median}, Expected = {expected_medians[i]}')\n",
    "    \n",
    "    # Verify median matches expected\n",
    "    assert median == expected_medians[i], f'Median mismatch! Got {median}, expected {expected_medians[i]}'\n",
    "    m.satisfies_assertions()
    print()

print("✅ All median tests passed!")
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Practice Problems {#practice-problems}\n",
    "\n",
    "Let's solve some common heap-based problems:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def heap_sort(arr):\n",
    "    \"\"\"Sort array using heap sort algorithm\"\"\"\n",
    "    # Build max heap\n",
    "    max_heap = MaxHeap()\n",
    "    for num in arr:\n",
    "        max_heap.insert(num)\n",
    "    \n",
    "    # Extract elements in descending order\n",
    "    result = []\n",
    "    while max_heap.size() > 0:\n",
    "        result.append(max_heap.delete_max())\n",
    "    \n",
    "    # Reverse to get ascending order\n",
    "    return result[::-1]\n",
    "\n",
    "# Test heap sort\n",
    "print(\"=== Heap Sort Test ===\")\n",
    "test_arr = [64, 34, 25, 12, 22, 11, 90]\n",
    "print(f\"Original array: {test_arr}\")\n",
    "sorted_arr = heap_sort(test_arr)\n",
    "print(f\"Sorted array:   {sorted_arr}\")\n",
    "print(f\"Correctly sorted: {sorted_arr == sorted(test_arr)}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_k_largest(arr, k):\n",
    "    \"\"\"Find k largest elements using min-heap (counter-intuitive but efficient!)\"\"\"\n",
    "    if k <= 0 or k > len(arr):\n",
    "        return []\n",
    "    \n",
    "    min_heap = MinHeap()\n",
    "    \n",
    "    for num in arr:\n",
    "        if min_heap.size() < k:\n",
    "            min_heap.insert(num)\n",
    "        elif num > min_heap.min_element():\n",
    "            min_heap.delete_min()  # Remove smallest of the k largest\n",
    "            min_heap.insert(num)   # Add new larger element\n",
    "    \n",
    "    # Extract all elements\n",
    "    result = []\n",
    "    while min_heap.size() > 0:\n",
    "        result.append(min_heap.delete_min())\n",
    "    \n",
    "    return result\n",
    "\n",
    "def find_k_smallest(arr, k):\n",
    "    \"\"\"Find k smallest elements using max-heap\"\"\"\n",
    "    if k <= 0 or k > len(arr):\n",
    "        return []\n",
    "    \n",
    "    max_heap = MaxHeap()\n",
    "    \n",
    "    for num in arr:\n",
    "        if max_heap.size() < k:\n",
    "            max_heap.insert(num)\n",
    "        elif num < max_heap.max_element():\n",
    "            max_heap.delete_max()  # Remove largest of the k smallest\n",
    "            max_heap.insert(num)   # Add new smaller element\n",
    "    \n",
    "    # Extract all elements\n",
    "    result = []\n",
    "    while max_heap.size() > 0:\n",
    "        result.append(max_heap.delete_max())\n",
    "    \n",
    "    return result\n",
    "\n",
    "# Test k-largest and k-smallest\n",
    "print(\"\\n=== K-Largest and K-Smallest Tests ===\")\n",
    "test_data = [7, 10, 4, 3, 20, 15]\n",
    "k = 3\n",
    "\n",
    "print(f\"Array: {test_data}\")\n",
    "print(f\"K = {k}\")\n",
    "\n",
    "k_largest = find_k_largest(test_data, k)\n",
    "k_smallest = find_k_smallest(test_data, k)\n",
    "\n",
    "print(f\"\\nK largest elements: {sorted(k_largest, reverse=True)}\")\n",
    "print(f\"Expected (sorted desc): {sorted(test_data, reverse=True)[:k]}\")\n",
    "\n",
    "print(f\"\\nK smallest elements: {sorted(k_smallest)}\")\n",
    "print(f\"Expected (sorted asc): {sorted(test_data)[:k]}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def merge_k_sorted_lists(lists):\n",
    "    \"\"\"Merge k sorted lists using min-heap\"\"\"\n",
    "    # Use tuples: (value, list_index, element_index)\n",
    "    min_heap = MinHeap()\n",
    "    result = []\n",
    "    \n",
    "    # Initialize heap with first element from each non-empty list\n",
    "    for i, lst in enumerate(lists):\n",
    "        if lst:  # Non-empty list\n",
    "            min_heap.insert((lst[0], i, 0))\n",
    "    \n",
    "    while min_heap.size() > 0:\n",
    "        # Get the minimum element\n",
    "        val, list_idx, elem_idx = min_heap.delete_min()\n",
    "        result.append(val)\n",
    "        \n",
    "        # Add next element from the same list if available\n",
    "        if elem_idx + 1 < len(lists[list_idx]):\n",
    "            next_val = lists[list_idx][elem_idx + 1]\n",
    "            min_heap.insert((next_val, list_idx, elem_idx + 1))\n",
    "    \n",
    "    return result\n",
    "\n",
    "# Test merge k sorted lists\n",
    "print(\"\\n=== Merge K Sorted Lists Test ===\")\n",
    "lists = [\n",
    "    [1, 4, 5],\n",
    "    [1, 3, 4], \n",
    "    [2, 6]\n",
    "]\n",
    "\n",
    "print(f\"Input lists: {lists}\")\n",
    "merged = merge_k_sorted_lists(lists)\n",
    "print(f\"Merged result: {merged}\")\n",
    "\n",
    "# Verify correctness\n",
    "all_elements = []\n",
    "for lst in lists:\n",
    "    all_elements.extend(lst)\n",
    "expected = sorted(all_elements)\n",
    "print(f\"Expected: {expected}\")\n",
    "print(f\"Correct: {merged == expected}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class PriorityQueue:\n",
    "    \"\"\"Priority Queue implementation using max-heap (higher priority = higher value)\"\"\"\n",
    "    \n",
    "    def __init__(self):\n",
    "        self.heap = MaxHeap()\n",
    "    \n",
    "    def enqueue(self, item, priority):\n",
    "        \"\"\"Add item with given priority\"\"\"\n",
    "        self.heap.insert((priority, item))\n",
    "    \n",
    "    def dequeue(self):\n",
    "        \"\"\"Remove and return highest priority item\"\"\"\n",
    "        if self.heap.size() == 0:\n",
    "            return None\n",
    "        priority, item = self.heap.delete_max()\n",
    "        return item\n",
    "    \n",
    "    def peek(self):\n",
    "        \"\"\"View highest priority item without removing\"\"\"\n",
    "        if self.heap.size() == 0:\n",
    "            return None\n",
    "        priority, item = self.heap.max_element()\n",
    "        return item\n",
    "    \n",
    "    def is_empty(self):\n",
    "        return self.heap.size() == 0\n",
    "    \n",
    "    def size(self):\n",
    "        return self.heap.size()\n",
    "\n",
    "# Test Priority Queue\n",
    "print(\"\\n=== Priority Queue Test ===\")\n",
    "pq = PriorityQueue()\n",
    "\n",
    "# Add tasks with different priorities\n",
    "tasks = [\n",
    "    (\"Fix critical bug\", 10),\n",
    "    (\"Write documentation\", 3),\n",
    "    (\"Code review\", 7),\n",
    "    (\"Security patch\", 9),\n",
    "    (\"Update README\", 2)\n",
    "]\n",
    "\n",
    "print(\"Adding tasks:\")\n",
    "for task, priority in tasks:\n",
    "    pq.enqueue(task, priority)\n",
    "    print(f\"  {task} (priority: {priority})\")\n",
    "\n",
    "print(\"\\nProcessing tasks by priority:\")\n",
    "while not pq.is_empty():\n",
    "    task = pq.dequeue()\n",
    "    print(f\"  Processing: {task}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Real-World Examples {#real-world-examples}\n",
    "\n",
    "Let's implement some practical applications of heaps:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class TaskScheduler:\n",
    "    \"\"\"Task scheduler using heap for deadline management\"\"\"\n",
    "    \n",
    "    def __init__(self):\n",
    "        self.tasks = MinHeap()  # Min-heap by deadline\n",
    "        self.current_time = 0\n",
    "    \n",
    "    def add_task(self, name, deadline, duration):\n",
    "        \"\"\"Add task with deadline and duration\"\"\"\n",
    "        self.tasks.insert((deadline, name, duration))\n",
    "        print(f\"Added task '{name}' (deadline: {deadline}, duration: {duration})\")\n",
    "    \n",
    "    def process_next_task(self):\n",
    "        \"\"\"Process the task with earliest deadline\"\"\"\n",
    "        if self.tasks.size() == 0:\n",
    "            print(\"No tasks to process\")\n",
    "            return\n",
    "        \n",
    "        deadline, name, duration = self.tasks.delete_min()\n",
    "        self.current_time += duration\n",
    "        \n",
    "        if self.current_time <= deadline:\n",
    "            print(f\"✅ Completed '{name}' on time (finished at {self.current_time}, deadline was {deadline})\")\n",
    "        else:\n",
    "            print(f\"⚠️  Completed '{name}' LATE (finished at {self.current_time}, deadline was {deadline})\")\n",
    "    \n",
    "    def show_remaining_tasks(self):\n",
    "        \"\"\"Show remaining tasks sorted by deadline\"\"\"\n",
    "        if self.tasks.size() == 0:\n",
    "            print(\"No remaining tasks\")\n",
    "            return\n",
    "        \n",
    "        print(\"Remaining tasks (by deadline):\")\n",
    "        # Note: This is for demonstration. In practice, you wouldn't access internal structure\n",
    "        temp_tasks = []\n",
    "        while self.tasks.size() > 0:\n",
    "            task = self.tasks.delete_min()\n",
    "            temp_tasks.append(task)\n",
    "            deadline, name, duration = task\n",
    "            print(f\"  {name} (deadline: {deadline}, duration: {duration})\")\n",
    "        \n",
    "        # Restore tasks\n",
    "        for task in temp_tasks:\n",
    "            self.tasks.insert(task)\n",
    "\n",
    "# Test Task Scheduler\n",
    "print(\"=== Task Scheduler Example ===\")\n",
    "scheduler = TaskScheduler()\n",
    "\n",
    "# Add tasks\n",
    "scheduler.add_task(\"Write report\", 10, 3)\n",
    "scheduler.add_task(\"Fix bug\", 5, 2)\n",
    "scheduler.add_task(\"Team meeting\", 8, 1)\n",
    "scheduler.add_task(\"Code review\", 15, 4)\n",
    "\n",
    "print(\"\\nInitial task list:\")\n",
    "scheduler.show_remaining_tasks()\n",
    "\n",
    "print(\"\\nProcessing tasks:\")\n",
    "while scheduler.tasks.size() > 0:\n",
    "    scheduler.process_next_task()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class StreamingMedian:\n",
    "    \"\"\"Real-time median calculation for streaming data\"\"\"\n",
    "    \n",
    "    def __init__(self):\n",
    "        self.median_heap = MedianMaintainingHeap()\n",
    "        self.count = 0\n",
    "        self.sum = 0\n",
    "    \n",
    "    def add_number(self, num):\n",
    "        \"\"\"Add new number to stream\"\"\"\n",
    "        self.median_heap.insert(num)\n",
    "        self.count += 1\n",
    "        self.sum += num\n",
    "    \n",
    "    def get_median(self):\n",
    "        \"\"\"Get current median\"\"\"\n",
    "        return self.median_heap.get_median()\n",
    "    \n",
    "    def get_mean(self):\n",
    "        \"\"\"Get current mean\"\"\"\n",
    "        return self.sum / self.count if self.count > 0 else 0\n",
    "    \n",
    "    def get_stats(self):\n",
    "        \"\"\"Get comprehensive statistics\"\"\"\n",
    "        return {\n",
    "            'count': self.count,\n",
    "            'sum': self.sum,\n",
    "            'mean': self.get_mean(),\n",
    "            'median': self.get_median() if self.count > 0 else None\n",
    "        }\n",
    "\n",
    "# Simulate streaming financial data\n",
    "print(\"\\n=== Streaming Median for Financial Data ===\")\n",
    "stream = StreamingMedian()\n",
    "\n",
    "# Simulate stock prices coming in real-time\n",
    "stock_prices = [100.5, 101.2, 99.8, 102.1, 98.5, 103.0, 97.2, 104.5]\n",
    "\n",
    "print(\"Processing streaming stock prices:\")\n",
    "print(f\"{'Price':<8} {'Count':<6} {'Mean':<8} {'Median':<8}\")\n",
    "print(\"-\" * 35)\n",
    "\n",
    "for price in stock_prices:\n",
    "    stream.add_number(price)\n",
    "    stats = stream.get_stats()\n",
    "    print(f\"{price:<8.1f} {stats['count']:<6} {stats['mean']:<8.2f} {stats['median']:<8.1f}\")\n",
    "\n",
    "print(f\"\\nFinal statistics: {stream.get_stats()}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class LoadBalancer:\n",
    "    \"\"\"Simple load balancer using min-heap to track server loads\"\"\"\n",
    "    \n",
    "    def __init__(self, servers):\n",
    "        self.servers = MinHeap()  # (load, server_id)\n",
    "        for server_id in servers:\n",
    "            self.servers.insert((0, server_id))  # Initially no load\n",
    "        self.total_requests = 0\n",
    "    \n",
    "    def assign_request(self, request_load=1):\n",
    "        \"\"\"Assign request to least loaded server\"\"\"\n",
    "        if self.servers.size() == 0:\n",
    "            return None\n",
    "        \n",
    "        # Get least loaded server\n",
    "        current_load, server_id = self.servers.delete_min()\n",
    "        \n",
    "        # Update load and put back\n",
    "        new_load = current_load + request_load\n",
    "        self.servers.insert((new_load, server_id))\n",
    "        \n",
    "        self.total_requests += 1\n",
    "        return server_id\n",
    "    \n",
    "    def get_server_loads(self):\n",
    "        \"\"\"Get current load distribution\"\"\"\n",
    "        loads = {}\n",
    "        temp_servers = []\n",
    "        \n",
    "        # Extract all to see loads\n",
    "        while self.servers.size() > 0:\n",
    "            load, server_id = self.servers.delete_min()\n",
    "            temp_servers.append((load, server_id))\n",
    "            loads[server_id] = load\n",
    "        \n",
    "        # Restore servers\n",
    "        for load, server_id in temp_servers:\n",
    "            self.servers.insert((load, server_id))\n",
    "        \n",
    "        return loads\n",
    "\n",
    "# Test Load Balancer\n",
    "print(\"\\n=== Load Balancer Example ===\")\n",
    "lb = LoadBalancer([\"Server-A\", \"Server-B\", \"Server-C\"])\n",
    "\n",
    "print(\"Simulating incoming requests:\")\n",
    "print(f\"{'Request':<10} {'Assigned To':<12} {'Server Loads':<30}\")\n",
    "print(\"-\" * 55)\n",
    "\n",
    "# Simulate 10 requests with varying loads\n",
    "request_loads = [1, 2, 1, 3, 1, 1, 2, 1, 1, 2]\n",
    "\n",
    "for i, load in enumerate(request_loads, 1):\n",
    "    assigned_server = lb.assign_request(load)\n",
    "    current_loads = lb.get_server_loads()\n",
    "    loads_str = \", \".join([f\"{k}:{v}\" for k, v in sorted(current_loads.items())])\n",
    "    print(f\"Request {i:<3} {assigned_server:<12} {loads_str}\")\n",
    "\n",
    "print(f\"\\nTotal requests processed: {lb.total_requests}\")\n",
    "print(f\"Final server loads: {lb.get_server_loads()}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Summary and Key Takeaways\n",
    "\n",
    "### 🎯 **What You've Learned:**\n",
    "\n",
    "1. **Heap Fundamentals**:\n",
    "   - Complete binary tree structure\n",
    "   - Array representation with index relationships\n",
    "   - Min-heap and max-heap properties\n",
    "\n",
    "2. **Core Operations**:\n",
    "   - `bubble_up()` and `bubble_down()` for maintaining heap property\n",
    "   - `insert()` and `delete_min/max()` operations\n",
    "   - Time complexity: O(log n) for modifications, O(1) for peek\n",
    "\n",
    "3. **Advanced Applications**:\n",
    "   - **TopK Data Structure**: Efficient k-smallest elements maintenance\n",
    "   - **Median Maintenance**: Two-heap technique for streaming median\n",
    "   - **Priority Queues**: Task scheduling and resource management\n",
    "\n",
    "4. **Problem-Solving Patterns**:\n",
    "   - Use min-heap for k-largest problems (counter-intuitive!)\n",
    "   - Two-heap pattern for median/percentile problems\n",
    "   - Heap + tuple technique for complex priority systems\n",
    "\n",
    "### 🚀 **When to Use Heaps**:\n",
    "- ✅ Need frequent min/max operations\n",
    "- ✅ Priority-based processing\n",
    "- ✅ Streaming data with ordering requirements\n",
    "- ✅ Partial sorting (top-k elements)\n",
    "- ✅ Graph algorithms (Dijkstra, Prim)\n",
    "\n",
    "### ⚠️ **When NOT to Use Heaps**:\n",
    "- ❌ Need complete sorted output\n",
    "- ❌ Frequent random access to elements\n",
    "- ❌ Search for arbitrary elements\n",
    "- ❌ Small, static datasets\n",
    "\n",
    "### 💡 **Practice Next**:\n",
    "1. Implement heap-based algorithms (heap sort, k-way merge)\n",
    "2. Solve LeetCode heap problems\n",
    "3. Build a complete priority queue system\n",
    "4. Implement Dijkstra's algorithm using heaps\n",
    "\n",
    "---\n",
    "\n",
    "**🎉 Congratulations!** You now have a comprehensive understanding of heap data structures and their applications. The combination of theory, implementation, and real-world examples should give you the confidence to use heaps effectively in your projects!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}